# Dragonfly鍵交換について
Dragonfly key exchangeは，
- パスワードとかパスフレーズを使っている
- 離散対数問題(の困難性)を使っている
- 鍵交換プロトコルの一つ

# 定義

- パスワード ..... 秘密かつ2者間で共有された単語とかの，要するに証明鍵
- a | b ..... ビット列aとビット列bの連結を示す
- len(a) ..... ビット列aの長さを返す関数
- lsb(a) ..... ビット列aの最後のビットを返す関数
- lgr(a, b) ..... aと素数bをとって，ルジャンドル記号を返す関数
  - ルジャンドル記号 .....aとbが互いに素でaが法であるbの平方余剰のとき+1，それ以外(平方非余剰)のとき-1と定義する記号のこと
- min(a,b) ..... aとbの文字列を辞書順にみたときに小さいほうを返し，aとbが等しい時は0を返す関数
- max(a,b)..... aとbの文字列を辞書順にみたときに大きいほうを返し，aとbが等しい時は0を返す関数

# 命名規則

- 大文字または大文字で始まる語は群の要素(ここでは，有限巡回群のみを考える)である
- 小文字または小文字で始まる語は，スカラーである
- 楕円曲線上の点は，必ずx,y座標を持つ

# 離散対数ベースの暗号について

- Dragonflyは離散対数ベースの暗号を使う
  - 鍵共有と認証のため
- 交換する人同士はパラメータの一つの集合の中で，短命の鍵(=一時的な鍵)を計算する
- 群は，短命の鍵の計算のことだと言える
- 群はFinite Field CryptographyまたはElliptic Curve Cryptographyのベースとなるもの

# 演算の定義
- スカラーの全体をS, 群をGとする. このとき，スカラー演算とは，写像scalar-op: S×G ∋ (x, Y) |-> Z ∈ Gである. これは関数のように`Z = scalar-op(x, Y)`とも書かれる. 言いかえれば, scalar-opとはスカラーxと群の元Yを群の元Zへと移す写像である.

-　スカラー演算とは，写像をとるscalar-opが

- 要素演算 ..... 要素Xと要素Yを選択して3つめの要素をつくる

Z = element-op(X,Y)

- 逆演算 ..... Xの単位元がYになるような要素を返す

Y = inverse(X)

# 楕円曲線ベースの暗号の定義

- p ..... 素数
- GF(p) ..... 素数の領域
- 暗号群 ..... 楕円曲線上の点からなる楕円曲線群の部分群
- 曲線方程式の条件を満たすGF(p)による要素は無限遠の点と一緒に特定する要素
- ECC群の群演算は楕円曲線上の足し算である

- a, bは定義した曲線方程式のGF(p)からの要素の一部
- 点(x, y)は，GF(p) * GF(p) の中の点で，(y^2 - x^3 - a*x - b) mod p = 0のときだけ楕円曲線上の点となる
- 点G ..... ECC群の生成のために役に立つ楕円曲線上の点
  - Gは十分に大きな素数 .... 楕円曲線加算について順番なので
- q ..... 素数かつ，GとGによって生成された暗号の部分群の大きさ

- 楕円曲線群 ..... 群要素を

## (x,y)ペアの条件

- x > 0 かつ y > 0 かつ根底の領域の素数より小さい
- x,y座標が曲線の方程式の条件を満たし，無限遠ではない曲線上の点をもたらす
- どちらかが満たされていなかったら，(x,y)のペアは有効な要素ではない

## 演算の定義

- スカラー演算 ..... 点自身の何倍かの曲線の点を追加する．
  - ここではYのx倍の曲線上の点をZとおく．

  Z = scalar-op(x, Y) = x*Y

- 要素演算 ..... 曲線上の2点を加算する．
  
  Z = X + Y

  Z = element-op(X, Y) = X + Y

- 逆関数　 ..... 要素の加算で，逆元とは0となる．
  - 楕円曲線群の無限遠の点

  R + inverse(R) = "0"

- 楕円曲線群 ..... 群要素を整数に変換する写像関数
  - q = F(Q)
  - X座標を返すために使用する
- scalar-op ..... element-opの反復として見ることができる

    Y = scalar-op(1, Y)

    x = 1に関して，

    Y = scalar-op(x, Y) = element-op(Y, Scalar-op(x-1,Y))

element-op(X, Y)の定義 ..... RFC6090を参照

# 有限領域暗号の定義

p .....素数

GF(p) .....素数領域

pの余剰である整数

FFC群 ..... GF(p)*の部分群で，*は0を除くという意味．乗法群

FFCのための群演算 ..... pを法とする掛け算

要素G ..... GF(p)*の要素で，FFC群の生成元として便利．乗法の位数は\cfrac{(p - 1)}{2}より十分大きな素数の余りであるような

q ..... 素数，Gの乗法の位数

 -> Gによって生成されるGF(p)の部分群のサイズ

スカラ演算 ..... 素数の余剰の発生源の累乗法

## 数字がFFC群で恒等の要素の条件
次の2つの条件を両方満たす必要がある
1. 1 < 要素 < p - 1
2. 群の位数に基づく要素のモジュール累乗法(何？) = 1

# Dragonfly Key Exchangeの定義

## 2つのパーティの条件
1. 2つのパーティは共通のパスワードを持っている
   1. パスワードを保持する
   2. 検証者がいるときは拡張しない
   
   ->クライアントサーバープロトコルと不変の役割が同時に開始することのできるP2P Appも使われる
2. 両方がEECまたはFFCを使う

## 前処理
- 二つのピアはドメインパラメータ集合の中で，秘密の要素を導く
  - "hunting-and-pecking"技術
  1. EECのため
  2. FFCのため

   これらはSection3.2.に書かれている
    - しかし，合意された安全で決定的な方法ならなんでもよい
      - 例えば[hash2ec]の技術はEEC群のために使われている

## Dragonfly Exchangeの構成
- 2つのメッセージ交換から構成される
1. Commit exchange

お互いがパスワードが1つだということを約束する

2. Confirm exchange

パスワードの情報を確認する

## 副作用
秘密鍵が本物であると証明された

## 使用関数
 - H() .....ランダム関数
 - F() ..... マッピング関数
 - KDF() ..... 鍵導出関数

# 前提

- 攻撃回避のための前提

1. 関数H ..... 可変長のバイナリ列をxビットの長さで固定長のバイナリ列にする写像をとるランダムオラクル([RANDOR]を参照)

    H: \{0,1\}^* --> \{0,1\}^x

2. 関数F ..... 群の中から要素を選んで，整数を返すマッピング関数．
   1. EEC群 ..... 楕円曲線上の点のx座標を返す

        ECC: x = F(P), where P=(x,y)

   2. FFC群 ..... 恒等関数
      - FFC群のすべての要素がすでに素数より小さい整数であるため

      FFC: x = F(x)

3. 関数KDF ..... k，label，nを必要とする鍵導出関数
- k ..... キーを引き延ばすためのキー
- label ..... キーに結合するラベル
- n ..... 目的の出力を指し示す

stretch = KDF-n(k, label)

※len(stretch) = n となるようにする

4. 選ばれた群に関しての離散対数問題の困難性

G，PとY = G^x \pmod pが与えられたとき，xを決定することは計算的に実行不可能だということ

同様に，ECC群に関して，曲線定義(aとb)と生成元とY = x * Gが与えられたとき，xを決定するのは計算的に実行不可能だということ

5. 共有されているパスワードがあるパスワードのプールが存在する

- 例 : 辞書の文字
  - プールの各パスワードは，共有されたパスワードである確率が等しい
  - 潜在的な攻撃者.....プールを入手する機会を持っている
  

# パスワードの導出

## 交換前にやること

- 














