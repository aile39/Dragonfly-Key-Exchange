# Dragonflyについて

- パスワード，パスフレーズを用いた離散対数暗号を使った鍵交換プロトコル


# 定義

- パスワード ..... 秘密かつ2者間で共有された，潜在的に混沌としていない(=整然としている?)単語などの認証キー
- a | b ..... ビット列aとビット列bの結合
- len(a) ..... ビット列aの長さ
- lsb(a) ..... ビット列aの最後のビットを返す
- lgr(a, b) ..... aと素数bをとって，aとbが互いに素でaが法であるbの平方余剰のとき+1，それ以外(平方非余剰)のとき-1を返す
- min(a,b) ..... aとbの文字列を辞書順にみたときに早いほうを返す．aとbが等しい時は0を返す
- max(a,b)..... aとbの文字列を辞書順にみたときに遅いほうを返す．aとbが等しい時は0を返す

# 慣習

大文字またはその頭文字語 .....有限巡回群の要素

小文字またはその頭文字語 .....スカラー
楕円曲線上の点 ..... 必ず$x,y$座標を持っている

# 離散対数暗号について

- Dragonnflyは離散対数暗号を使う
  - 鍵合意と認証のため
- 当事者は領域パラメータのあるまとまりについて短命の鍵(=一時的な鍵)を演繹する
- 短命の鍵の演繹のことをここでは群と呼ぶ
- 群はFFCまたはECCに準拠する

# 演算の定義
- スカラー演算 ..... スカラーxと群要素Yを選択して要素をつくる

$Z = scalar-op(x, Y)$

- 要素演算 ..... 要素Xと要素Yを選択して3つめの要素をつくる

$Z = element-op(X,Y)$

- 逆演算 ..... Xの単位元がYになるような要素を返す

$Y = inverse(X)$

# 楕円曲線暗号の定義

- $p$ ..... 素数
- $GF(p)$ ..... 素数領域
- 暗号群 ..... 楕円曲線上の点からなる楕円曲線群の部分群
- 曲線方程式の条件を満たすGF(p)による要素 ..... 無限遠の点と一緒に特定する(何を?)要素
- ECC群の群演算 ..... 楕円曲線上の足し算

- $a, b$ ..... 定義した曲線方程式のGF(p)による要素
- 点$(x, y)$ ..... $GF(p) * GF(p)$ の中の点，$(y^2 - x^3 - a*x - b)\pmod p = 0$のときだけ楕円曲線上の点となる
- 点$G$ ..... ECC群の生成のために役に立つ楕円曲線上の点
  - $G$は十分に大きな素数 .... 楕円曲線加算について順番なので
- $q$ ..... 素数かつ，$G$と$G$によって生成された暗号の部分群の大きさ

- 楕円曲線群 ..... 群要素を

## (x,y)ペアの条件

- x $>$ 0 かつ y $>$ 0 かつ根底の領域の素数より小さい
- $x,y$座標が曲線の方程式の条件を満たし，無限遠ではない曲線上の点をもたらす
- どちらかが満たされていなかったら，$(x,y)$のペアは有効な要素ではない

## 演算の定義

- スカラー演算 ..... 点自身の何倍かの曲線の点を追加する．
  - ここではYのx倍の曲線上の点をZとおく．

  $Z = scalar-op(x, Y) = x*Y$

- 要素演算 ..... 曲線上の2点を加算する．
  
  $Z = X + Y$

  $Z = element-op(X, Y) = X + Y$

- 逆関数　 ..... 要素の加算で，逆元とは0となる．
  - 楕円曲線群の無限遠の点

  $R + inverse(R) = "0"$

- 楕円曲線群 ..... 群要素を整数に変換する写像関数
  - q = F(Q)
  - X座標を返すために使用する
- scalar-op ..... element-opの反復として見ることができる

    $Y = scalar-op(1, Y)$

    $x = 1$に関して，

    $Y = scalar-op(x, Y) = element-op(Y, Scalar-op(x-1,Y))$

element-op(X, Y)の定義 ..... RFC6090を参照

# 有限領域暗号の定義

p .....素数

GF(p) .....素数領域

pの余剰である整数

FFC群 ..... GF(p)*の部分群で，*は0を除くという意味．乗法群

FFCのための群演算 ..... pを法とする掛け算

要素G ..... GF(p)*の要素で，FFC群の生成元として便利．乗法の位数は$\cfrac{(p - 1)}{2}$より十分大きな素数の余りであるような

q ..... 素数，Gの乗法の位数

 -> Gによって生成されるGF(p)の部分群のサイズ

スカラ演算 ..... 素数の余剰の発生源の累乗法

## 数字がFFC群で恒等の要素の条件
次の2つの条件を両方満たす必要がある
1. $1 < 要素 < p - 1$
2. $群の位数に基づく要素のモジュール累乗法(何？) = 1$

# Dragonfly Key Exchangeの定義

## 2つのパーティの条件
1. 2つのパーティは共通のパスワードを持っている
   1. パスワードを保持する
   2. 検証者がいるときは拡張しない
   
   ->クライアントサーバープロトコルと不変の役割が同時に開始することのできるP2P Appも使われる
2. 両方がEECまたはFFCを使う

## 前処理
- 二つのピアはドメインパラメータ集合の中で，秘密の要素を導く
  - "hunting-and-pecking"技術
  1. EECのため
  2. FFCのため

   これらはSection3.2.に書かれている
    - しかし，合意された安全で決定的な方法ならなんでもよい
      - 例えば[hash2ec]の技術はEEC群のために使われている

## Dragonfly Exchangeの構成
- 2つのメッセージ交換から構成される
1. Commit exchange

お互いがパスワードが1つだということを約束する

2. Confirm exchange

パスワードの情報を確認する

## 副作用
秘密鍵が本物であると証明された

## 使用関数
 - H() .....ランダム関数
 - F() ..... マッピング関数
 - KDF() ..... 鍵導出関数

# 前提

- 攻撃回避のための前提

1. 関数H ..... 可変長のバイナリ列をxビットの長さで固定長のバイナリ列にする写像をとるランダムオラクル([RANDOR]を参照)

    $H: \{0,1\}^* --> \{0,1\}^x$

2. 関数F ..... 群の中から要素を選んで，整数を返すマッピング関数．
   1. EEC群 ..... 楕円曲線上の点のx座標を返す

        $ECC: x = F(P), where P=(x,y)$

   2. FFC群 ..... 恒等関数
      - FFC群のすべての要素がすでに素数より小さい整数であるため

      $FFC: x = F(x)$

3. 関数KDF ..... k，label，nを必要とする鍵導出関数
- k ..... キーを引き延ばすためのキー
- label ..... キーに結合するラベル
- n ..... 目的の出力を指し示す

$stretch = KDF-n(k, label)$

※len(stretch) = n となるようにする

4. 選ばれた群に関しての離散対数問題の困難性

$G，P$と$Y = G^x \pmod p$が与えられたとき，xを決定することは計算的に実行不可能だということ

同様に，ECC群に関して，曲線定義(aとb)と生成元と$Y = x * G$が与えられたとき，xを決定するのは計算的に実行不可能だということ

5. 共有されているパスワードがあるパスワードのプールが存在する

- 例 : 辞書の文字
  - プールの各パスワードは，共有されたパスワードである確率が等しい
  - 潜在的な攻撃者.....プールを入手する機会を持っている
  

# パスワードの導出

## 前提















