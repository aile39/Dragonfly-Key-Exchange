encoded by UTF-8

// TODO 2. (~23) -> 3. (~3?) -> 　1.2.2. (~7?) -> 4. 5. and more (~15?)
RFC 7664 https://tools.ietf.org/html/rfc7664
-----------------------------------
Internet Reserch Task Force (IRTF)        D.Harkins, Ed.
論調の運用: 7664                  Aruba Networks
カテゴリー: 情報提供                        November 2015
ISSN: 2070-1721

             Dragonfly Key Exchange

要旨
    このドキュメントはパスワードとパスフレーズを使った真正性を証明する離散対数暗号作成法を用いた鍵交換を記す．
    それは能動的な攻撃，受動的な攻撃，そしてオフラインの辞書攻撃に耐性がある．このドキュメントはCrypto Forum Reserch Group (CFRG) によって保護されている．

このメモの位置づけ
    このドキュメントはインターネット標準化手段の仕様書ではない．それは情報提供を目的として公開されている．

    このドキュメントはInternet Reserch Task Force (IRTF) によって保護されている．IRTFは研究と開発活動のインターネットのつながりの結果を出版する．このRFCはInternet Reserch Task Force (IRCF) の暗号フォーラムリサーチグループの1人以上の個々の意見を表す．IRSG((Internet Research Steering Group))に妥当だと認められた出版物はインターネット標準化のどのレベルにもふさわしいものではない．RFC5741のセクション2を見て．

    このドキュメントの今の位置づけ，正誤表，およびそれに対する意見についての情報は， http://www.rfc-editor.org/info/rfc7664 から得ることができるだろう．

著作権表記
    Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.

    このドキュメントは，このドキュメントの発行日に実施する BCP 78 と IETF文書のIETF法的規定(http://trustee.ietf.org/license-info)の対象になる．注意してこれらのドキュメントを見てほしい，なぜなら，このドキュメントに関しての権利と制限を説明しているからだ．

// TODO menu (finished)
目次
    1.    はじめに
        1.1.    言語についての用語法
        1.2.    定義
            1.2.1.   表記
            1.2.2.   辞書攻撃への抵抗
    2.    離散対数暗号
        2.1.    楕円曲線暗号
        2.2.    有限領域暗号
    3.    The Dragonfly Key Exchange
        3.1.    前提((仮定))
        3.2.    パスワード要素の導出
            3.2.1.   ECC群と Hunting and Pecking
            3.2.2.   MODP群と Hunting and Pecking
        3.3.    約束交換
        3.4.    確認交換
    4.    セキュリティの考慮すべき点
    5.    リファレンス
        5.1.    標準的((模範的))なリファレンス
        5.2.    有益なリファレンス
    謝辞
    筆者の住所


1. はじめに

    パスワードとパスフレーズは今日のインターネット上で認証として広く行われている方法である．認証のためにパスワードやパスフレーズを使う多くのプロトコルはパスワードの認識の証拠として演繹されたパスワードデータを交換する(例えば，[RFC7296]や[RCF5403])．これはどこかで攻撃者が演繹されたパスワードデータに一致するまで潜在的なパスワードのプールを通して走らせて，実証する物を計算することで，プロトコル上で積極的または受動的な攻撃のどちらかから十分な知識を収集するオフライン辞書攻撃まで交換を公開する．

    このプロトコルはおそらくオフライン辞書攻撃に抵抗するパスワードを使って相互認証を行う方法で効率の良い交換を果たすための離散対数暗号を使う．このドキュメントにおいてのCFRGの統一見解は大まかであった．

1.1. 言語についての用語法
    このドキュメント中のキーワードの "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", そして "OPTIONAL" は RFC 2119 で説明されたように解釈される．

1.2. 定義
1.2.1. 表記
    次に述べる表記はこのメモで使われている．

    パスワード
        共有し，秘密で，かつ潜在的に低エントロピーな単語またはフレーズまたはコードまたは同等の者と相互に認証するための証明書として使われるキー．
        人間の言語の文字に制限されない．
    a | b
        ビット列"a"とビット列"b"を連結することを示す．
    len(a)
        ビット列"a"のビット長を示す．
    lsb(a)
        ビット列"a"の最も最後のビットを返す
    lgr(a, b)
        "a"と素数"b"をとり，ルジャンドルの記号を返す((aとbが互いに素であるとき，aが法bの平方剰余であるとき +1，平方非剰余であるとき -1))
    min(a, b)
        "a"と"b"の文字列の辞書的に小さいほう，または"a"と"b"が等しいときゼロ(0)を返す．
    max(a, b)
        "a"と"b"の文字列の辞書的に大きいほう，または"a"と"b"が等しいときゼロ(0)を返す．

    このメモにおいての慣習は大文字の文字または頭文字語は有限巡回群の中の要素を表すと同時にスカラーは小文字の文字または頭文字語を示すことだ．楕円曲線上の点を表す要素は暗黙の複数の要素からなる自然数を持っている，すなわちそれはxとy座標の両方を持っている．
1.2.2. 辞書攻撃への抵抗
    // TODO 1.2.2.

2. 離散対数暗号
    Dragonflyは鍵合意と認証を成し遂げるために離散対数暗号を使う([SP800-56A]を参照)．交換するためのそれぞれの当事者は領域パラメータの特定のまとまりに関して短命の鍵を演繹する(ここでは，群として呼ぶ )．群は有限領域暗号(FFC)または楕円曲線暗号(ECC)に準拠することができる．

    3つの演算は群の両方の典型として定義される．

    o   スカラー演算  -- 別の要素を生成するためにスカラーと群の中の要素を選択する -- Z = scalar-op(x, Y)．
    o   要素演算 -- 3つめの要素を生成するために群の中の2つの要素を選択する -- Z = element-op(X, Y)．
    o   逆演算 -- 要素を選択して2つの要素演算が群の単位元要素の生成であるような別の要素を返す -- Y = inverse (X)．
2.1. 楕円曲線暗号
    Dragonflyを使ったECC群のための領域パラメータは，

    o   素数である p ，決定的な素数領域 GF(p)．暗号の群は楕円曲線上の点からなる完全な楕円曲線群の部分群となり，曲線方程式の条件を満たすGF(p)からの要素，無限遠の点と一緒に特定する要素として役に立つ．ECC群のための群演算は楕円曲線上の足し算である．

    o   定義した曲線方程式のGF(p)からの要素 a, b．GF(p) x ((ここでは積(外積)の意味？)) GF(p) の中の点(x, y)は(y^2 - x^3 - a*x - b) mod p が0のときだけ楕円曲線上となる．

    o   ECC群の生成として役に立つ楕円曲線上の点 G ．楕円曲線加算について順番なので選ばれたGは十分に大きな素数である．

    o   素数のqは，Gの位数なので，したがってGによって生成された暗号部分群の大きさ．

    (x,y)のペアは次のとき，有効な要素である 1) xとy座標の両方が0より大きく，かつ典型的な根底にある領域の素数より小さい 2) xとy座標が曲線の方程式の条件を満たし，無限遠の点ではない曲線上の有効な点をもたらす．もしどちらかが条件を満たしていなかったら，(x,y)のペアは有効な要素ではない．

    スカラー演算はそれ自身の何倍かの曲線上の点を追加する．点Yは別の点Zを生産するためにx倍掛けられる．

        Z = scalar-op(x, Y) = x*Y

    要素演算は曲線上の2点を加算する．点XとYは別の点Zを生産するために加算される．

        Z = element-op(X, Y) = X + Y

    逆関数は要素の加算で，それの逆は "0"，それは楕円曲線群の無限遠の点であることのように定義される．

        R + inverse(R) = "0"

    楕円曲線群は群要素を整数に変換する写像関数である必要があり，q = F(Q)．写像関数は移される点のx座標を返す((ために))このメモを使った．

    scalar-op(x, Y) は定義に従ってelement-op()のXの反復として見られることができる．

        Y = scalar-op(1, Y)

        Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), x > 1に関して

    楕円曲線上の2点を加算する方法(言い換えれば， element-op(X, Y))の定義は[RFC6090]に見ることができる．

    ノート : これは別の楕円曲線領域パラメータであり，余因子で， // TODO 後回し

2.2.    有限領域暗号
    Dragonflyに使われているFFC群のための領域パラメータは，

    o   素数のp，決定的な素数領域GF(p)，整数のpを法とする．FFC群はGF(p)* の部分群となり，GF(p)の0ではない要素乗法群．FFCのための群演算はpを法とする掛け算だ．

    o  FFC群についての生成元として役に立つGF(p)*の中の要素のG．Gはその乗法の位数は((p-1) / 2)の十分に大きい素数除数であるような．

    o   素数のq，Gの乗法の位数であり，したがってGによって生成されるGF(p)の暗号法の部分群のサイズでもある．

    数字はFFC群で恒等の要素で，もし 1) 1から素数pに1満たない間，排他的な(言い換えれば，1 < 要素 < p - 1)．かつ 2) 群位数に基づく要素のモジュール累乗法はone(1)に等しい．それらの条件のどちらかが適用できなかったら，数字は恒等の要素ではない．

    スカラー演算は素数を法とした発生元の累乗法である．
3.    The Dragonfly Key Exchange
    Dragonfly exchangeには2つのパーティがあり，AliceとBobの利便性と因習を目的にして．2つのパーティは帯域外の構造が実証された共有のパスワードを持っていて，それら両方は特殊領域パラメータ集合(ECCまたはFFCのどちらか)を使うことに同意する．Dragonfly exchangeの中では，AliceとBobの両方は共有パスワードについて同一の見解を共有する．言い換えれば，一面ではパスワードを保持し，他の一面では不可逆的な検証者を保持している場合には，それは"拡張"されない．これはDragonflyに伝統的なクライアントサーバープロトコルと，不変の役割があっていずれの当事者も開始することができる(かつ両方の当事者が同時に実行することができる)ピアツーピアアプリケーションもまた使われることを許す．

    Dragonfly exchangeの開始に先立って，ツーピアは選ばれたドメインパラメータ集合の中で秘密の要素を導く．秘密の要素を決定するための2つの"hunting-and-pecking"技術，一つはECCのためで，一つはFFCのため，はSection3.2.に記載されている，しかし，合意された安全で決定的な方法の上ならなんでも利用できる．例えば，[hash2ec]に記載されている技術はECC群のために利用できる．

    Dragonfly exchange は2つのメッセージ交換から構成され，双方がパスワードの一つの推測を約束する"Commit exchange"と，双方がパスワードの情報を確認する"Confirm Exchange"．Dragonfly exchangeを実行することの副作用は，本物であると証明された，共有された，暗号の強度が合意済みの群によって設定された秘密鍵．

    Dragonflyはランダム関数，H()，マッピング関数，F()，鍵導出関数，KDF()を使う．
3.1.    前提
    Dragonflyプロトコルに対する攻撃を避けるために，いくつかの基本的な前提は作られる:

    1. 関数Hはxビットの長さで固定のバイナリ列の上に可変長のバイナリ列の写像をとる"ランダムオラクル"([RANDOR]を参照)．

    H: {0,1}^* --> {0,1}^x

    2. 関数Fは群の中から要素を選び，整数を返すマッピング関数．ECC群に関して，関数Fは(楕円曲線上の点の)要素のx座標を返す，FFC群に関して，関数Fは恒等関数である(FFC群のすべての要素が既に素数より小さい整数であるため)．

    ECC: x = F(P), where P=(x,y)

    FFC: x = F(x)

    3. 関数KDFは，キーを引き伸ばすためのキー，k，キーに結合するためのラベル，label，および目的の出力の表示を指し示す，nを必要とする鍵導出関数であり（[SP800-108]などを参照)，

    stretch = KDF-n(k, label)

    len(stretch)がnに等しくなるように．

    4. 選ばれた群に関しての離散対数問題は難しい．すなわち，G,PとY = G^x mod pが与えられたとき，xを決定することは計算的に実行不可能だ．同じように，ECC群に関して，曲線定義と生成元とY = x * Gが与えられたとき，xを決定することは計算的に実行不可能だ．

    5. 2つのピアによって共有されているパスワードが引き出されるパスワードのプールが存在する．このプールは例えば辞書の文字から構成されている．このプールの各パスワードは共有されたパスワードが存在する確率が平等だ．全ての潜在的な攻撃者はパスワードから構成されたこのプールを入手する機会を持っている．

    6. ピアは質のいい乱数を生成する能力を持っている．
3.2.    パスワード要素の導出
    情報の交換に先立って，ピアは選ばれた領域パラメータ集合によって定義された群の中でパスワード要素(PE)と呼ばれる秘密の要素を導かなければならない(MUST)．パスワードを知らない攻撃者の視点から，PEは取り決められた群のランダムな要素となる．2つの例が完全性のためにここに記載されているが，選択したグループの要素に，秘密の文字列を決定論的にマッピングする方法はすべて使用できます。たとえば、ECCグループの[hash2ec]の手法です．ここで説明した手法とは異なる手法を使用する場合、秘密文字列にはピアのIDを含める必要があります（SHOULD）．

    PEを戻すために，両方のピアはパスワードの共通認識を持たなければならない(MUST)．// TODO : どのパスワードも必要な処理があった場合(例えば，国際化を支えるために)，必要な処理が行われたパスワードはそのとき共有の認証情報として使われる．もしどちらか一方がパスワードのハッシュ化された版を蓄えていたら(ランダムデータと一体になったパスワードのハッシュ法は「ソルト」と呼ばれる)，ソルトを交換の開始に先立って相手に伝えることは必要になるだろう．，ハッシュ化されたパスワードはそのとき共有の認証情報として使われる．

    // TODO: Note:

    PEを選ぶための確定的仮定はseedを選ぶことと，そのとき群特異的なhunting-and-pecking技術，一つはFFCのためでもう一つはECCのため，を行うことから始める．

    与えられたパスワードからPEを見つけるのに向いている，hunting-and-pecking ループの反復の数を決定しようとする試みであるサイドチャネル攻撃を阻止するために，安全な要素，k，は少なくともk反復法はいつも行われているということができるようにするということが使われている．ECCペアを探すためのhunting-and-peckingループの反復のnは一つの確率は

    セキュリティパラメータkは，PEがkの反復が十分に小さいよりも大きい値を取る値を探す確率のような十分に大きな(値を)セットすべきである．(Section 4 を参照)

    最初に，8ビットカウンタは1にセットされて，シークレットベース((良い日本語が思いつかない))な一方向性関数の，2人の参加者のアリスとボブ，パスワード，カウンタの固有値の合成を使っていて，それは，

    base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)

    と表せる．固有値((固有性?))は必須の順序付けを提供するためにmax()関数とmin()関数に渡される．

    baseはそのとき[FIS186-4]の技術をつかって伸長される．鍵導出関数KDFは長さが群ドメインパラメータ集合＋一時的な値が導き出すための不変定数64から((つくられる))素数の長さと等しいビットストリームを生成するために使われ，一時的な値は生成するseedに減られるモジュール式で，

    n = len(p) + 64

    temp = KDF-n(base, "Dragonfly Hunting and Pecking")

    seed = (temp mod (p - 1)) + 1

    文字列は生成された一時的な値が実例となる目的のみのためでなければならない．Dragonfly key exchangeの実現はKDFとともに使用明細ラベルを使うべきである．

    Note:

    seedはそのとき群特異的なhunting-and-pecking技術に移動される．

    //ここ日本語が地獄
    もしDragonflyがランダムワンタイムパスワードを交換する能力をもつプロトコルならば，それらは各々がプロトコルは違うPEを生成する続きが起こるようにするためのベースの計算結果を加えられるべき．
3.2.1.   ECC群と Hunting and Pecking

    ECC仕様のhunting-and-pecking技術は楕円曲線上の正当な点が見つかるまでループすることを伴う．seedは x^2 + a*x + b がpの法の平方余剰であるかどうかをチェックする曲線方程式とともにx座標として使われる．もし違ったら，カウンタをインクリメントして，新しいbaseとseedを生成し，hunting and peckingを続ける．もしpを法とする平方余剰なら，x座標はseedの価値を割り当てられて，かつ現在のbaseは記憶される．hunting-and-pecking loopが終わったとき，x座標はy座標を導く曲線方程式と((して？))つかわれる．あいまいさはy座標が正当であろうという評価と，記憶されたbaseの下位ビットが明確にy座標をただす決定をする評価して以来存在する．結果として発生する(x,y)ペアはパスワード要素(PE)からくる．

    アルゴリズム的に，プロセスはこのようになる．

    /* 省略 */

    valueが素数の余りの平方余剰かどうかを調べることはサイドチャネルアタックの中の値に関する情報を漏らすことができる((=サイドチャネル攻撃によって情報が漏れてしまう))．そのため，



    アルゴリズム的に，valueが平方余剰かに関係なく見つけるマスキングテクニックはこのようになる．

    /*省略*/

3.2.2.   MODP群と Hunting and Pecking
    MODP仕様の hunting-and-pecking技術はランダムな要素，それは生成器として使うとき，を探すことを必然的に伴う．秘密の生成器は

    アルゴリズム的に，プロセスはこのようになる．
3.3.    約束交換
    約束交換の中で，双方はパスワードの一つの推量を約束する．ピアはスカラーと要素を生成して，お互いに交換して，共通かつ共有された秘密を生成するために相手のスカラーと要素を処理する．

    最初に，各々のピアは2つのランダムな数字を生成する，それらは1よりも大きくて選ばれたドメインパラメータ集合からなるorderより小さいプライベートかつ覆い隠す．

    1 < private < p
    1 < mast < p

    それらの2つの秘密とパスワード要素はそのときスカラーと要素を構成するために使われる．

    scalar = (private + mask) mod q
    Element = inverse(scalar-op(mask, PE))

    もしスカラーが2より小さいなら，プライベートとマスクは投げ捨てて，新しい値を生成しなければならない．一度正当なスカラーと要素が作られると，マスクは長さが必要とされなくて，取り返しのつかないほど壊れてしまう．

    ピアは彼らのスカラーと要素を交換して，peer-scalarとPeer-Elementとみなす，ピアのスカラーと要素をチェックする．もしピアが同一のスカラーと要素なら，言い換えると，もしスカラーがpeer-scalarと恒等かつ要素がPeer-Elementと恒等ならば，それは鏡映攻撃の現れで，その交換は失敗されなければならない．もし値が一致しなければ，peer-scalarとPeer-Elementは有効な要素となる．有効なpeer-scalarを目的として，それは1から排他的なqの間でなければならない．Peer-Elementの妥当性確認は暗号システムの種類による，ECC要素のような(x,y)ペアの妥当性確認はSection2.1に定められていて，FFC要素のような数字の正当性確認はSection2.2.に定められている．もし一方のpeer-scalarかPeer-Elementの妥当性確認が失敗したら，交換は終わって，認証は失敗しなければならない．もし両方のpeer-scalarかPeer-Elementが正当だったら，共有された秘密を導くためのパスワード要素といっしょに使われて，ssは

    ss = F(scalar-op(private,element-op(peer-Element,scalar-op(peer-scalar, PE))))

    鍵の分離と暗号法の衛生を実行するために，共有された秘密は二つのサブキー，承認キーのkckとマスターキーのmk，の中で伸長される．サブキーのそれぞれは少なく見積もっても選ばれた群に中で使われている素数の長さ．

    kck | mk = KDF-n(ss, "Dragonfly Key Derivation")

    where n = len(p)*2
3.4.    確認交換
    確認交換の中で，双方は彼らの共通の秘密と，それゆえの，共有のパスワードの所有権を持っていることを生成する．

    確認交換はランダム関数H()，それは確認鍵と約束交換の中の交換された2つのスカラーと要素からなる，の出力データの交換で構成される．スカラーと要素の順番は，スカラーが要素より前で，送り主の値は受け取り主の値よりも前．だから各々のピアからの見方は，このことを起こすだろう．

    confirm = H(kck | scalar | peer-scalar | Element | Peer-Element | <sender-id>)

    <sender-id>の裏付けるメッセージの送り主の固有性はどこに．この固有性は，当然Section3.2の中のbaseの生成の中の確認交換の送り主によって寄与されるだろう．

    二つのピアはそれらの確認で交換され，受け取った相手のピアの確認書の正当性を検証する．もし相手のピアの確認書が有効ならば，認証が成功して，有効でなければ，認証が失敗する．

    もし認証が失敗したら，Dragonfly交換は取り返しのつかないほど壊れ続けるに違いなく，全ての一時的な状態が固有の一端としてつくられる．もし認証が失敗しなかったら，mkは証明された，もう一つのプロトコル，例としてIPsecで相手のデータを保護するために，で使うことができる秘密鍵としてエクスポートできる．
4.    セキュリティの考慮すべき点
5.    リファレンス
5.1.    標準的((模範的))なリファレンス
5.2.    有益なリファレンス